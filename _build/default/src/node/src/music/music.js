// Generated by Melange
'use strict';

var Caml_array = require("melange.js/caml_array.js");
var Caml_option = require("melange.js/caml_option.js");
var Curry = require("melange.js/curry.js");
var Stdlib = require("melange/stdlib.js");
var Stdlib__Array = require("melange/array.js");
var Stdlib__Int = require("melange/int.js");
var Stdlib__List = require("melange/list.js");
var Stdlib__Printf = require("melange/printf.js");

var notes = [
  "C",
  "C#",
  "D",
  "D#",
  "E",
  "F",
  "F#",
  "G",
  "G#",
  "A",
  "A#",
  "B"
];

function eq(l, r) {
  if (l.pitch === r.pitch) {
    return l.octave === r.octave;
  } else {
    return false;
  }
}

function to_number(note) {
  return note.pitch;
}

function of_number(pitch, octave) {
  if (pitch > 11) {
    return Stdlib.invalid_arg("Number out of range");
  } else {
    return {
            pitch: pitch,
            octave: octave,
            scale_position: undefined
          };
  }
}

function of_name(note, octave) {
  var pitch_o = Stdlib__Array.find_index((function (name) {
          return note === name;
        }), notes);
  if (pitch_o !== undefined) {
    return of_number(pitch_o, octave);
  }
  throw Stdlib.failwith(Curry._1(Stdlib__Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Note.of_name should always be able to find a note, but couldn't find ",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: /* End_of_format */0
                      }
                    },
                    _1: "Note.of_name should always be able to find a note, but couldn't find %s"
                  }), note));
}

function to_string(note) {
  return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: /* No_padding */0,
                      _2: /* No_precision */0,
                      _3: /* End_of_format */0
                    }
                  },
                  _1: "%s%d"
                }), Caml_array.get(notes, note.pitch), note.octave);
}

function transpose(scale_positionOpt, param) {
  var scale_position = scale_positionOpt !== undefined ? Caml_option.valFromOption(scale_positionOpt) : undefined;
  var octave = param.octave;
  var old_pitch = param.pitch;
  return function (operator) {
    var pitch = (old_pitch + operator | 0) % 12;
    var octaveChange = (old_pitch + operator | 0) / 12 | 0;
    var octave$1 = octave + octaveChange | 0;
    return {
            pitch: pitch,
            octave: octave$1,
            scale_position: scale_position
          };
  };
}

function transpose_notes(root, notes) {
  return Stdlib__List.map((function (operator) {
                return transpose(undefined, root)(operator);
              }), notes);
}

function compare(n1, n2) {
  return Stdlib__Int.compare(Math.imul(n1.octave, 12) + n1.pitch | 0, Math.imul(n2.octave, 12) + n2.pitch | 0);
}

function dist(from, target) {
  return Math.imul(12, target.octave - from.octave | 0) - (from.pitch - target.pitch | 0) | 0;
}

var c4 = of_number(0, 4);

var cs4 = of_number(1, 4);

var d4 = of_number(2, 4);

var ds4 = of_number(3, 4);

var e4 = of_number(4, 4);

var f4 = of_number(5, 4);

var fs4 = of_number(6, 4);

var g4 = of_number(7, 4);

var gs4 = of_number(8, 4);

var a4 = of_number(9, 4);

var as4 = of_number(10, 4);

var b4 = of_number(11, 4);

var Note = {
  notes: notes,
  eq: eq,
  to_number: to_number,
  of_number: of_number,
  of_name: of_name,
  to_string: to_string,
  transpose: transpose,
  transpose_notes: transpose_notes,
  compare: compare,
  dist: dist,
  c4: c4,
  cs4: cs4,
  d4: d4,
  ds4: ds4,
  e4: e4,
  f4: f4,
  fs4: fs4,
  g4: g4,
  gs4: gs4,
  a4: a4,
  as4: as4,
  b4: b4
};

var major_notes = {
  hd: 0,
  tl: {
    hd: 4,
    tl: {
      hd: 7,
      tl: /* [] */0
    }
  }
};

var minor_notes = {
  hd: 0,
  tl: {
    hd: 3,
    tl: {
      hd: 7,
      tl: /* [] */0
    }
  }
};

var dominant7_notes = {
  hd: 0,
  tl: {
    hd: 4,
    tl: {
      hd: 7,
      tl: {
        hd: 10,
        tl: /* [] */0
      }
    }
  }
};

var major7_notes = {
  hd: 0,
  tl: {
    hd: 4,
    tl: {
      hd: 7,
      tl: {
        hd: 11,
        tl: /* [] */0
      }
    }
  }
};

var minor7_notes = {
  hd: 0,
  tl: {
    hd: 3,
    tl: {
      hd: 7,
      tl: {
        hd: 10,
        tl: /* [] */0
      }
    }
  }
};

function spell(root, chord) {
  switch (chord) {
    case /* Major */0 :
        return transpose_notes(root, major_notes);
    case /* Minor */1 :
        return transpose_notes(root, minor_notes);
    case /* Dominant7 */2 :
        return transpose_notes(root, dominant7_notes);
    case /* Major7 */3 :
        return transpose_notes(root, major7_notes);
    case /* Minor7 */4 :
        return transpose_notes(root, minor7_notes);
    
  }
}

var Chord = {
  major_notes: major_notes,
  minor_notes: minor_notes,
  dominant7_notes: dominant7_notes,
  major7_notes: major7_notes,
  minor7_notes: minor7_notes,
  spell: spell
};

var major_intervals = {
  hd: 0,
  tl: {
    hd: 2,
    tl: {
      hd: 4,
      tl: {
        hd: 5,
        tl: {
          hd: 7,
          tl: {
            hd: 9,
            tl: {
              hd: 11,
              tl: /* [] */0
            }
          }
        }
      }
    }
  }
};

var minor_intervals = {
  hd: 0,
  tl: {
    hd: 2,
    tl: {
      hd: 3,
      tl: {
        hd: 5,
        tl: {
          hd: 7,
          tl: {
            hd: 8,
            tl: {
              hd: 10,
              tl: /* [] */0
            }
          }
        }
      }
    }
  }
};

var chromatic_intervals = {
  hd: 0,
  tl: {
    hd: 1,
    tl: {
      hd: 2,
      tl: {
        hd: 3,
        tl: {
          hd: 4,
          tl: {
            hd: 5,
            tl: {
              hd: 6,
              tl: {
                hd: 7,
                tl: {
                  hd: 8,
                  tl: {
                    hd: 9,
                    tl: {
                      hd: 10,
                      tl: {
                        hd: 11,
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

function get_intervals(kind) {
  switch (kind) {
    case /* Major */0 :
        return major_intervals;
    case /* Minor */1 :
        return minor_intervals;
    case /* Chromatic */2 :
        return chromatic_intervals;
    
  }
}

function make_of_string(key, intervals) {
  var root = of_name(key, 4);
  var notes = Stdlib__List.map((function (interval) {
          return transpose(Caml_option.some(interval), root)(interval);
        }), intervals);
  return {
          key: key,
          root: root,
          notes: notes,
          intervals: intervals
        };
}

function make_of_int(octaveOpt, key, intervals) {
  var octave = octaveOpt !== undefined ? octaveOpt : 4;
  var root = of_number(key, octave);
  var notes$1 = Stdlib__List.map((function (interval) {
          return transpose(Caml_option.some(interval), root)(interval);
        }), intervals);
  return {
          key: Caml_array.get(notes, key),
          root: root,
          notes: notes$1,
          intervals: intervals
        };
}

function make_big_scale(scale, lo, ho) {
  var _octave = ho;
  var _notes = /* [] */0;
  while(true) {
    var notes = _notes;
    var octave = _octave;
    var curr_octave_scale = make_of_int(octave, scale.root.pitch, major_intervals);
    var new_notes = Stdlib__List.map((function (note) {
            return note.pitch + Math.imul(note.octave, 12) | 0;
          }), curr_octave_scale.notes);
    var match = octave === lo;
    if (match) {
      return Stdlib__List.concat({
                  hd: new_notes,
                  tl: notes
                });
    }
    _notes = {
      hd: new_notes,
      tl: notes
    };
    _octave = octave - 1 | 0;
    continue ;
  };
}

function get_path(scale, start_note, end_note) {
  var start_pos = start_note.pitch + Math.imul(start_note.octave, 12) | 0;
  var end_pos = end_note.pitch + Math.imul(end_note.octave, 12) | 0;
  if (start_pos === end_pos) {
    return {
            hd: start_pos,
            tl: /* [] */0
          };
  }
  var match = start_pos < end_pos ? [
      start_note,
      start_pos,
      end_note,
      end_pos
    ] : [
      end_note,
      end_pos,
      start_note,
      start_pos
    ];
  var upper_pos = match[3];
  var lower_pos = match[1];
  var big_scale = make_big_scale(scale, match[0].octave, match[2].octave);
  var result = {
    hd: lower_pos,
    tl: /* [] */0
  };
  var _curr = lower_pos;
  var _notes = big_scale;
  var _result = result;
  while(true) {
    var result$1 = _result;
    var notes = _notes;
    var curr = _curr;
    if (!notes) {
      return Stdlib__List.rev({
                  hd: upper_pos,
                  tl: result$1
                });
    }
    var tl = notes.tl;
    var hd = notes.hd;
    var match$1 = hd >= upper_pos;
    if (match$1) {
      return Stdlib__List.rev({
                  hd: upper_pos,
                  tl: result$1
                });
    }
    var match$2 = curr < hd;
    if (match$2) {
      _result = {
        hd: hd,
        tl: result$1
      };
      _notes = tl;
      _curr = hd;
      continue ;
    }
    _notes = tl;
    continue ;
  };
}

var Scale = {
  major_intervals: major_intervals,
  minor_intervals: minor_intervals,
  chromatic_intervals: chromatic_intervals,
  get_intervals: get_intervals,
  make_of_string: make_of_string,
  make_of_int: make_of_int,
  make_big_scale: make_big_scale,
  get_path: get_path
};

exports.Note = Note;
exports.Chord = Chord;
exports.Scale = Scale;
/* c4 Not a pure module */
